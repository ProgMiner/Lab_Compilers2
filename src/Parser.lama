-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

-- Primary expression
var primary = memo $ eta (decimal @ fun (x) {Const (stringInt (x))} |
                          lident  @ fun (x) {Var (x)} |
                          inbr (s ("("), exp, s (")"))),
    binopF = fun (l, op, r) { Binop (op, l, r) },
    binop = memo $ eta expr ({ [Left, {[s ("!!"), binopF]}]
                             , [Left, {[s ("&&"), binopF]}]
                             , [Nona, { [s ("=="), binopF]
                                      , [s ("!="), binopF]
                                      , [s ("<"), binopF]
                                      , [s ("<="), binopF]
                                      , [s (">"), binopF]
                                      , [s (">="), binopF]
                                      }]
                             , [Left, { [s ("+"), binopF]
                                      , [s ("-"), binopF]
                                      }]
                             , [Left, { [s ("*"), binopF]
                                      , [s ("/"), binopF]
                                      , [s ("%"), binopF]
                                      }]
                             }, primary),
    exp = memo $ eta binop;

var primaryStmt = memo $ eta syntax ( kSkip { Skip }
                                    | x=lident s[":="] v=exp { Assn (x, v) }
                                    | kRead x=inbr[s ("("), lident, s (")")] { Read (x) }
                                    | kWrite v=inbr[s ("("), exp, s (")")] { Write (v) }
                                    | ct=(kIf exp kThen stmt)
                                      cts=(kElif exp kThen stmt)*
                                      f=(kElse stmt)? kFi
                                      {
                                        foldr (
                                          fun (f, [_, c, _, t]) { If (c, t, f) },
                                          case f of Some ([_, f]) -> f | _ -> Skip esac,
                                          ct:cts
                                        )
                                      }
                                    | kWhile c=exp kDo b=stmt kOd { While (c, b) }
                                    | kDo b=stmt kWhile c=exp kOd { DoWhile (b, c) }
                                    | kFor p=stmt s[","] c=exp s[","] e=stmt kDo b=stmt kOd
                                      { Seq (p, While (c, Seq (b, e))) }
                                    ),
    stmt = memo $ eta expr ({[Left, {[s (";"), fun (l, op, r) { Seq (l, r) }]}]}, primaryStmt);
   

-- Public top-level parser
public parse = stmt;
