-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}


-- Primary expression
var primary = memo $ eta syntax (x=decimal { Const (stringInt (x)) } |
                                 x=lident  { Var (x) }               |
                                 inbr[s ("("), exp, s (")")]),
    binopF = fun (l, op, r) { Binop (op, l, r) },
    binop = memo $ eta expr ({ [Left, {[s ("!!"), binopF]}]
                             , [Left, {[s ("&&"), binopF]}]
                             , [Nona, { [s ("=="), binopF]
                                      , [s ("!="), binopF]
                                      , [s ("<"), binopF]
                                      , [s ("<="), binopF]
                                      , [s (">"), binopF]
                                      , [s (">="), binopF]
                                      }]
                             , [Left, { [s ("+"), binopF]
                                      , [s ("-"), binopF]
                                      }]
                             , [Left, { [s ("*"), binopF]
                                      , [s ("/"), binopF]
                                      , [s ("%"), binopF]
                                      }]
                             }, primary),
    exp = memo $ eta binop;

var primaryStmt = memo $ eta syntax ( kSkip { Skip }
                                    | x=lident s[":="] v=exp { Assn (x, v) }
                                    | kRead x=inbr[s ("("), lident, s (")")] { Read (x) }
                                    | kWrite v=inbr[s ("("), exp, s (")")] { Write (v) }
                                    ),
    stmt = memo $ eta expr ({[Left, {[s (";"), fun (l, op, r) { Seq (l, r) }]}]}, primaryStmt);
   

-- Public top-level parser
public parse = stmt;
