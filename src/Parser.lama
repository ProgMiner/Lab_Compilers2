-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")

-- Checks if a plain value "val" can be used in the context described by
-- the attribute "atr".
fun assertValue (atr, v, loc) {
  case atr of
    Ref  -> error ("reference expected", loc)
  | Void -> Ignore (v)
  | _    -> v
  esac
}

fun assertVoid (atr, v, loc) {
  case atr of
    Void -> v
  | Val  -> error ("value expected", loc)
  | _    -> error ("reference expected", loc)
  esac
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop (op) {
  [ syntax (pos -s[op])
  , fun (l, loc, r) {
      fun (a) {
        assertValue (a, Binop (op, l (Val), r (Val)), loc)
      }
    }
  ]
}

fun parens (p) {
  inbr (s("("), p, s(")"))
}

var primary = memo $ eta syntax (

  -- decimal constant
  loc=pos x=decimal { fun (a) { assertValue (a, Const (stringInt (x)), loc) } }

  -- identifier
  | x=lident { fun (a) {
    case a of
      Ref  -> Ref (x)
    | Val  -> Var (x)
    | _    -> Ignore (Var (x))
    esac
  } }

  | e=parens[exp] { e }

  | loc=pos kSkip                   { fun (a) { assertVoid (a, Skip, loc) } }
  | loc=pos kRead  x=parens[lident] { fun (a) { assertVoid (a, Read (x), loc) } }
  | loc=pos kWrite x=parens[exp]    { fun (a) { assertVoid (a, Write (x (Val)), loc) } }

  | loc=pos kIf ct=(exp -kThen exp) cts=(-kElif exp -kThen exp)* f=(-kElse exp)? kFi { fun (a) {
    foldr (
      fun (f, [c, t]) { If (c (Val), t (a), f) },
      case f of Some (f) -> f (a) | _ -> assertVoid (a, Skip, loc) esac,
      ct:cts
    )
  } }

  | loc=pos kWhile c=exp kDo b=exp kOd { fun (a) { assertVoid (a, While (c (Val), b (Void)), loc) } }
  | loc=pos kDo b=exp kWhile c=exp kOd { fun (a) { assertVoid (a, DoWhile (b (Void), c (Val)), loc) } }
  | loc=pos kFor p=exp s[","] c=exp s[","] e=exp kDo b=exp kOd { fun (a) {
      assertVoid (a, Seq (p (Void), While (c (Val), Seq (b (Void), e (Void)))), loc)
    } }
),

  basic = memo $ eta (expr ({[Right, {[s (":="), fun (l, loc, r) {
    fun (a) { assertValue (a, Assn (l (Ref), r (Val)), loc) }
  }]}],
                             [Left, map (binop, {"!!"})],
                             [Left, map (binop, {"&&"})],
                             [Nona, map (binop, {"==", "!=", "<", ">", "<=", ">="})],
                             [Left, map (binop, {"+", "-"})],
                             [Left, map (binop, {"*", "/", "%"})]
                            }, primary)),

  exp = memo $ eta syntax (basic | s1=basic s[";"] s2=exp { fun (a) { Seq (s1 (Void), s2 (a)) } });

-- Public top-level parser
public parse = syntax (s=exp { s (Void) });
